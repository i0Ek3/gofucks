# gofucks
A buntch of Go tips.

## Tips

- Go 中仅有值传递。
- 善用 `switch` 而不是多个 `if`。
- 使用 `chan struct{}` 来传递信号。
- 防止结构体字段用纯值方式初始化，可在结构体中添加 `_ struct{}` 字段。
- 允许对值为 `nil` 的 `slice` 添加元素，但对值为 `nil` 的 `map` 添加元素时，会造成运行时 `panic`。
- 检查 `map` 中的 `key` 是否存在，可以直接使用返回的第二个参数 `ok` 来判断。
- Go 中的可变参数作为函数参数时，必须放在最后一位。
- 想要修改 `string` 的值，需要借助 `[]byte`，修改后再转换为 `string`。
- 两个 `nil` 是不相等的，故无法通过 `!=` 进行比较。
- 对变量加锁后再进行复制，会将锁的状态一同复制。
- 在单独的 `for` 循环中，`break` 可以跳出循环。但在 `for select` 中，`break` 可以跳出 `select` 块，但不会跳出 `for` 循环。如需跳出 `for` 循环，可以配合 `goto` 使用 `label` 解决。
- `map` 是线程不安全的，可以通过 `sync.RWMutex` 加锁 或者使用线程安全的 `sync.Map` 来解决。
- `return` 会先于 `defer` 返回，且 `return` 不是原子操作，会分为赋值和返回两个部分。
- 在同一个作用域中，多次声明同一个变量名，后声明的变量仅在当前作用域产生效果。
- 使用值类型接收者定义的方法，调用的时候，使用的是值的副本，对副本操作不会影响原来的值。如果想要在调用函数中修改原来的值，可以使用指针接收者定义的方法。
- `for range` 中获取到的值是原本元素的副本。
- 在函数调用里面修改返回的切片，将会影响到原切片。通常我们新建一个切片，然后将修改后的结果复制到该新切片，而不是改变旧有切片。
- Go 语言中不存在引用变量，每个变量都占用一个唯一的内存位置。
- Go 中的预定义标识符（如 `string`、`len` 等）是可以作为变量使用的，但关键字不行，如 `default`。
- 当使用 `type` 声明一个新类型时，它不会继承原有类型的方法集。
- `init()` 函数不能被其他函数调用，包括 `main()` 函数，它总是第一个执行。
- 非命名类型（unamed type，如 `struct{}`、`[]string`、`interface{}`、`map[string]bool` 等）不能作为方法的接收者。[参考](https://go.dev/play/p/Xbdnni_JasU)
- 不同类型的值是不能相互赋值的，即使底层类型一样。对于底层类型相同的变量可以相互赋值的一个重要条件是，至少有一个变量不是有名类型（named type，如内置类型和用 `type` 声明的类型）。



## Magic Code

- [https://go.dev/play/p/R4OP-836tDo](https://go.dev/play/p/R4OP-836tDo) find the min.



## Credit

You All Guys!
